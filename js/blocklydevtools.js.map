{"version":3,"file":"js/blocklydevtools.js","sources":["webpack://GUI/./src/addons/addons/blocklydevtools/style.css","webpack://GUI/./src/addons/addons/blocklydevtools/_runtime_entry.js","webpack://GUI/./src/addons/addons/blocklydevtools/userscript.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/.pnpm/css-loader@1.0.1_webpack@4.47.0_webpack-cli@3.3.12_/node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/* Hide the ✏️ button on blocks that aren't top level */\\ng.blocklyDraggable[data-id]:not(.blocklyInsertionMarker):not(g.blocklyBlockCanvas>g.blocklyDraggable[data-id]:not(.blocklyInsertionMarker)) .sa-blocklyDevtoolsElement {\\n    display: none !important;\\n}\\n\\n/* Hide scrollbars on the XML editor */\\ndiv[data-isblocklydeveditor]::-webkit-scrollbar {\\n    display: none;\\n}\\ndiv[data-isblocklydeveditor] {\\n    scrollbar-width: none;\\n}\\n.sa-blocklyDevtoolsFadeOut {\\n    transition: 1s;\\n    opacity: 0;\\n}\\n.sa-blocklyDevtoolsError {\\n    color: red;\\n    font: 12pt monospace;\\n    background-color: rgb(0,0,20);\\n    border: 2px solid white;\\n    border-radius: 0.4rem;\\n    width: max-content;\\n    padding: 8px;\\n    cursor: auto;\\n}\\n.sa-blocklyDevtoolsEditor {\\n    padding: 10px;\\n    user-select: text;\\n    cursor: auto;\\n    font: 12pt monospace;\\n    box-shadow: 0px 0px 10px rgba(0,0,0,0.5);\\n    color: yellowgreen;\\n    border: 2px solid white;\\n    z-index: 998;\\n    border-radius: 0.8rem;\\n    width: max-content;\\n    background-color: rgb(0,0,30);\\n    overflow-x: hidden;\\n    max-height: 100vh;\\n    overflow-y: scroll;\\n    caret-color: white;\\n}\\n\\n.sa-blocklyDevtoolsButton {\\n    cursor: pointer;\\n    z-index: 999;\\n    line-height: 1rem;\\n}\", \"\"]);\n\n// exports\n","import _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nexport const resources = {\n    \"userscript.js\": _js,\n    \"style.css\": _css\n};","export default async function ({ addon, console }) {\n    while (true) { //Loop necessary for ScratchAddons\n        await addon.tab.waitForElement(\"svg.blocklySvg>g.blocklyWorkspace\", {\n            reduxCondition: (state) => !state.scratchGui.mode.isPlayerOnly,\n            markAsSeen: true\n        }); //Wait for the workspace to be ready. (Necessary for ScratchAddons)\n\n        var Blockly = window.Blockly; //Blockly is usually exposed by default.\n        if (!Blockly) {\n            Blockly = await addon.tab.traps.getBlockly(); //I doubt code in here will ever run.\n        }\n\n        if (!Blockly) { //If the Blockly global is not exposed or found manually, the script cannot do anything useful.\n            return \"Failed to find Blockly instance!\";\n        }\n\n        var workspace = Blockly.getMainWorkspace();\n\n        var dom = Blockly.Xml.workspaceToDom(workspace); //Export the workspace to a DOM representing the save XML.\n        workspace.addChangeListener(() => { //Every time the workspace changes, update the dom variable.\n            if (!document.querySelector(\"g.blocklyDraggable[data-id].blocklyInsertionMarker\")) { //Blockly will try to serialise insertion markers, which will cause an internal crash.\n                dom = Blockly.Xml.workspaceToDom(workspace);\n            }\n        });\n\n        const observerConfig = { childList: true, characterData: false, attributes: false, subtree: true }; //Config for MutationObservers.\n\n        const TabManager = { //Hacky fix to get the tab key working in the XML editor.\n            enableTab: function (keyEvent) { //Call with the key event and a string to insert at the text caret's position\n                if (keyEvent.keyCode === 9) {\n                    // Insert tab at cursor position\n                    this.insertTab();\n\n                    // Prevent switching focus to next element\n                    this.blockKeyEvent(keyEvent);\n                }\n            },\n            insertTab: function () { //Function to insert the tab char\n                if (window.getSelection) {\n                    const sel = window.getSelection();\n\n                    sel.modify(\"extend\", \"backward\", \"paragraphboundary\"); //Alter bounds of selection\n\n                    const pos = sel.anchorOffset; //Offset of caret in anchorNode (in the editor's case, this is the current Text node)\n\n                    if (sel.anchorNode) {\n                        sel.collapseToEnd();\n\n                        const node = sel.anchorNode;\n\n                        if (node instanceof HTMLElement) {\n                            //Get text before and after caret\n                            const preText = node.innerHTML.substring(0, pos);\n                            const postText = node.innerHTML.substring(pos, node.innerHTML.length);\n\n                            node.innerHTML = preText + \"&emsp;\" + postText; //Insert tab character\n                        } else if (node instanceof Node) {\n                            //Get text before and after caret\n                            const preText = node.nodeValue.substring(0, pos);\n                            const postText = node.nodeValue.substring(pos, node.nodeValue.length);\n\n                            node.nodeValue = preText + \"\\u2003\" + postText; //Insert tab character\n                        }\n\n                        sel.setPosition(node, pos + 1); //Move text caret forward\n                    }\n                }\n            },\n            blockKeyEvent: function (keyEvent) {\n                if (keyEvent.preventDefault) {\n                    keyEvent.preventDefault();\n                } else {\n                    keyEvent.returnValue = false;\n                }\n            }\n        };\n\n        function firefoxSpacingFix(elem) { //Fix for firefox adding a \\n at the end of every text node, which makes the editor feel janky.\n            elem.childNodes.forEach(element => {\n                if (element instanceof Text) {\n                    element.nodeValue = element.nodeValue.replace(/\\n/g, \"\");\n                }\n            })\n        }\n\n        function makeEditorContainer() {\n            var editor = document.createElement(\"div\");\n\n            editor.setAttribute(\"data-isblocklydeveditor\", \"true\"); //Attribute to identify element as editor\n            editor.contentEditable = true; //Allow editing of content\n\n            //Styling\n            editor.classList.add(\"sa-blocklyDevtoolsEditor\");\n            editor.classList.add(\"sa-blocklyDevtoolsElement\");\n\n            //Disable spellcheck and autocomplete.\n            editor.setAttribute(\"autocomplete\", \"false\");\n            editor.setAttribute(\"spellcheck\", \"false\");\n\n            //Prevent events from propagating to Blockly\n            editor.addEventListener(\"pointerdown\", (event) => {\n                event.stopPropagation();\n            }, {\n                capture: true\n            });\n            editor.addEventListener(\"wheel\", (event) => {\n                event.stopPropagation();\n            }, {\n                capture: true\n            });\n            editor.addEventListener(\"scroll\", (event) => {\n                event.stopPropagation();\n            }, {\n                capture: true\n            });\n            editor.addEventListener(\"contextmenu\", (event) => {\n                event.stopPropagation();\n            }, {\n                capture: true\n            });\n            editor.addEventListener(\"keydown\", (event) => {\n                TabManager.enableTab(event); //Fix for tab key\n\n            }, {\n                capture: true\n            });\n\n            return editor;\n        }\n\n        //CSS would normally be injected here.\n\n        if (!getBlocklyWorkspace()) {\n            return \"Failed to find Blockly SvgWorkspace!\";\n        }\n\n        function formatXml(xml, innerHTMLMode = false) { //Utility function to format XML, optionally outputting valid HTML\n            var formatted = '', indent = '';\n            var tab = '\\t';\n            xml.split(/>\\s*</).forEach(function (node) {\n                if (node.match(/^\\/\\w/)) indent = indent.substring(tab.length);\n                formatted += indent + '<' + node + '>\\r\\n';\n                if (node.match(/^<?\\w[^>]*[^\\/]$/)) indent += tab;\n            });\n            if (!innerHTMLMode) {\n                return formatted.substring(1, formatted.length - 3);\n            } else {\n                return formatted.substring(1, formatted.length - 3)\n                    .replace(/&/g, \"&amp;\")\n                    .replace(/</g, \"&lt;\")\n                    .replace(/>/g, \"&gt;\")\n                    .replace(/\\t/g, \"&emsp;\")\n                    .replace(/\\n/g, \"<br>\")\n                    .replace(/ /g, \"&nbsp;\");\n            }\n        }\n        function getBlocklyWorkspace() { //Get the svg workspace\n            return document.querySelector(\"svg.blocklySvg>g.blocklyWorkspace\");\n        }\n        function getBlocklyBlockCanvas() { //get the block canvas from the workspace\n            return getBlocklyWorkspace().querySelector(\"g.blocklyBlockCanvas\");\n        }\n        function getSvgPathFromBlock(blockElem) { //Get the svg path from an svg block\n            if (isNewBlocklyBlock(blockElem)) {\n                return blockElem.querySelector(\"g.blocklyDraggable[data-id]:not(.blocklyInsertionMarker)>path.blocklyPath[d]\");\n            }\n        }\n        function isNewBlocklyBlock(node) { //Is node a block svg that has not yet been hooked.\n            return node && node instanceof Element && node.tagName === \"g\" && node.classList.contains(\"blocklyDraggable\") && !node.classList.contains(\"blocklyInsertionMarker\") && node.hasAttribute(\"data-id\") && !node.hasAttribute(\"data-blocklydev-hooked\");\n        }\n        function makeXMLEditor(blockId, block, devWrapper) { //Make the XML editor for a blockId\n            function getXmlFromBlockId(id, dom) { //Utility function to get the block's XML string from a Blockly serialised DOM.\n                for (const element of dom.children) {\n                    if (element.tagName.toLowerCase() === \"block\" && element.getAttribute(\"id\") === id) {\n                        return element.outerHTML;\n                    }\n                }\n            }\n\n            function getXmlFromVarId(id, dom) { //Utility function to get the block's XML string from a Blockly serialised DOM.\n                var variables = dom.querySelector(\"variables\");\n                for (const element of variables.children) {\n                    if (element.tagName.toLowerCase() === \"variable\" && element.getAttribute(\"id\") === id) {\n                        return element.outerHTML;\n                    }\n                }\n            }\n\n            var originalXml = getXmlFromBlockId(blockId, dom); //Store the block's original, un-edited XML.\n\n\n            var container = makeEditorContainer(); //Create the editor\n\n            //Set the editor's contents to the formatted original XML.\n            container.innerHTML = formatXml(originalXml, true);\n            firefoxSpacingFix(container);\n\n            var referencesVars = block.getVars(); //Array of variable ids referenced by block (directly)\n            var editorVar = referencesVars[0]; //The variable to display\n            var secondaryEditor = makeEditorContainer(); //Create secondary editor\n            var originalVarXml = editorVar ? getXmlFromVarId(editorVar, dom) : null;\n\n            secondaryEditor.innerHTML = originalVarXml ? formatXml(originalVarXml, true) : \"\";\n            secondaryEditor.style.display = originalVarXml ? \"block\" : \"none\";\n            firefoxSpacingFix(container);\n\n            function update() { //Function called when the workspace updates\n                originalXml = getXmlFromBlockId(blockId, dom); //Update original XML\n                if (!originalXml) { //If it is now undefined, the block has been deleted or no longer exists, so remove listeners and exit.\n                    workspace.removeChangeListener(update);\n                    return;\n                }\n                referencesVars = block.getVars();\n                editorVar = referencesVars[0] || false;\n                originalVarXml = editorVar ? getXmlFromVarId(editorVar, dom) : null;\n                if (originalVarXml) {\n                    secondaryEditor.innerHTML = formatXml(originalVarXml, true);\n                    secondaryEditor.style.display = \"block\";\n                    firefoxSpacingFix(container);\n                } else {\n                    secondaryEditor.innerHTML = \"\";\n                    secondaryEditor.style.display = \"none\";\n                }\n                container.innerHTML = formatXml(originalXml, true); //Update contents\n                firefoxSpacingFix(container);\n            }\n\n            workspace.addChangeListener(update); //Register change listener\n\n            container.save = function () { //Function to save\n                var xmlStr = (Blockly.Xml.domToText || Blockly.utils.xml.domToText)(dom); //Convert the dom to string\n                if (!xmlStr.includes(originalXml)) { //If the domn does not contain the original block XML, it is impossible to save changes.\n                    throw new Error(\"Workspace XML does not contain block!\");\n                }\n                xmlStr = xmlStr.replace(originalXml, container.textContent); //Replace original XML with modified XML.\n                if (originalVarXml) {\n                    xmlStr = xmlStr.replace(originalVarXml, secondaryEditor.textContent);\n                }\n                //xmlStr = xmlStr.replace(/\\u2003/g, \"\").replace(/\\n/g, \"\");\n                xmlStr = xmlStr.replace(/\\u00A0/g, \"\\u0020\"); //Replace any non-breaking spaces with normal ones.\n                var tempDom = (Blockly.Xml.textToDom || Blockly.utils.xml.textToDom)(xmlStr);\n                if (tempDom.querySelector(\"parsererror\")) {\n                    tempDom.querySelectorAll(\"parsererror\").forEach(err => {\n                        var display = document.createElement(\"div\");\n                        display.innerText = err.querySelector(\"div\").innerText;\n                        display.classList.add(\"sa-blocklyDevtoolsError\");\n                        display.classList.add(\"sa-blocklyDevtoolsElement\");\n                        display.addEventListener(\"pointerdown\", (event) => { event.stopPropagation(); }, { capture: true });\n                        display.addEventListener(\"contextmenu\", (event) => { event.stopPropagation(); }, { capture: true });\n                        devWrapper.appendChild(display);\n                        setTimeout(() => {\n                            display.classList.add(\"sa-blocklyDevtoolsFadeOut\");\n                            setTimeout(() => {\n                                display.remove();\n                            }, 1000);\n                        }, 3000);\n                    });\n                    return;\n                }\n                dom = tempDom; //Update the DOM variable.\n\n                workspace.clear(); //Clear the workspace\n                Blockly.Xml.domToWorkspace(dom, workspace); //Load the DOM\n                if (workspace.getToolbox() //If the blockly instance has a toolbox, it needs to be refreshed,\n                ) {\n                    workspace.getToolbox().refreshSelection();\n                }\n            }\n\n            return [container, secondaryEditor];\n        }\n        function processBlock(element) { //Function to hook block svg element\n            if (isNewBlocklyBlock(element)) { //Check if we have not already hooked it\n                var blockId = element.getAttribute(\"data-id\"); //Get the id\n                var internalBlock = workspace.getBlockById(blockId); //Get the internal block object\n                if (!internalBlock) {\n                    return;\n                }\n                internalBlock.tooltip ||= internalBlock.type || \"unknown\"; //If the block does not have a tooltip, set it to it's opcode.\n                const devWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject'); //Create a foreignObject element to allow HTML inside of SVG.\n                const btnWrapper = document.createElement(\"div\"); //Wrapper for buttons to keep them on the same row\n\n                btnWrapper.style.cursor = \"auto\"; //Fix for cursor being the grab hand\n                btnWrapper.style.width = \"max-content\";\n\n                const btn = document.createElement(\"span\"); //Create the edit button\n                btn.classList.add(\"sa-blocklyDevtoolsButton\");\n                btn.classList.add(\"sa-blocklyDevtoolsElement\");\n                btn.setAttribute(\"data-is-blocklydev-btn\", \"true\");\n                btn.innerText = \"✏️\"; //📝✏️\n\n                const save = document.createElement(\"span\"); //Create the save button\n                save.classList.add(\"sa-blocklyDevtoolsButton\");\n                save.classList.add(\"sa-blocklyDevtoolsElement\");\n                save.setAttribute(\"data-is-blocklydev-editor-btn\", \"true\");\n                save.style.display = \"none\";\n                save.innerText = \"💾\";\n\n                const collapse = document.createElement(\"span\"); //Create the collapse/uncollapse button\n                collapse.classList.add(\"sa-blocklyDevtoolsButton\");\n                collapse.classList.add(\"sa-blocklyDevtoolsElement\");\n                collapse.setAttribute(\"data-is-blocklydev-editor-btn\", \"true\");\n                collapse.style.display = \"none\";\n                collapse.innerText = \"⬆️\";\n\n                const bin = document.createElement(\"span\"); //Create the force delete button\n                bin.classList.add(\"sa-blocklyDevtoolsButton\");\n                bin.classList.add(\"sa-blocklyDevtoolsElement\");\n                bin.setAttribute(\"data-is-blocklydev-btn\", \"true\");\n                bin.innerText = \"🗑️\";\n\n                //Get the block's hull and calculate bounding box. Used to calculate where to position elements.\n                const path = getSvgPathFromBlock(element);\n                var bbox = path.getBBox();\n\n                //Attributes and styles for the foreignObject\n                //Width and height are 1 instead of 0 because firefox is won't render the element if it doesn't have a positive size.\n                devWrapper.setAttributeNS(null, \"width\", 1);\n                devWrapper.setAttributeNS(null, \"height\", 1);\n\n                devWrapper.style.overflow = \"visible\";\n                devWrapper.style.userSelect = \"none\";\n\n                devWrapper.setAttributeNS(null, \"class\", \"blocklyText\");\n                devWrapper.setAttributeNS(null, \"y\", \"0\");\n                devWrapper.setAttributeNS(null, \"text-anchor\", \"middle\");\n                devWrapper.setAttributeNS(null, \"dominant-baseline\", \"middle\");\n                devWrapper.setAttributeNS(null, \"dy\", \"0\");\n                devWrapper.setAttributeNS(null, \"x\", bbox.width);\n                devWrapper.setAttributeNS(null, \"transform\", `translate(0, 0) `);\n\n                //Add buttons to button wrapper\n                btnWrapper.appendChild(btn);\n                btnWrapper.appendChild(save);\n                btnWrapper.appendChild(collapse);\n                btnWrapper.appendChild(bin);\n\n                //Add button wrapper to foreignObject\n                devWrapper.appendChild(btnWrapper);\n\n                //Add foreignObject to block SVG\n                element.appendChild(devWrapper);\n\n                //The block has been hooked\n                element.setAttribute(\"data-blocklydev-hooked\", \"true\");\n\n                //Stop events reaching Blockly\n                btnWrapper.addEventListener(\"pointerdown\", (event) => {\n                    event.stopPropagation();\n                });\n\n                //Edit button handler.\n                btn.addEventListener(\"pointerdown\", (event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    if (element.hasAttribute(\"data-id\")) {\n                        blockId = element.getAttribute(\"data-id\");\n                        if (devWrapper.querySelector(\"div[data-isblocklydeveditor]\")) { //If the editor exists, remove it.\n                            devWrapper.querySelectorAll(\"div[data-isblocklydeveditor]\").forEach(element => {\n                                element.remove();\n                            });\n                            save.style.display = \"none\";\n                            collapse.style.display = \"none\";\n                        } else {\n                            //Add editor if it does not exist.\n                            internalBlock = workspace.getBlockById(blockId);\n                            makeXMLEditor(blockId, internalBlock, devWrapper).forEach(editorSegment => {\n                                devWrapper.appendChild(editorSegment);\n                            });\n\n                            save.style.display = \"initial\";\n                            if (internalBlock.nextConnection || internalBlock.previousConnection) {\n                                collapse.style.display = \"initial\";\n                            }\n                        }\n                    }\n                }, {\n                    capture: true\n                });\n\n                collapse.addEventListener(\"pointerdown\", (event) => { //Handler for collapse button\n                    event.stopPropagation();\n                    event.preventDefault();\n                    if (element.hasAttribute(\"data-id\")) {\n                        blockId = element.getAttribute(\"data-id\");\n                        internalBlock = workspace.getBlockById(blockId);\n\n                        internalBlock.setCollapsed(!internalBlock.isCollapsed()); //Toggle collapsed for the current block\n\n                        var collapsed = internalBlock.isCollapsed(); //Store collapsed as variable for efficiency\n\n                        //Loop through all sub-blocks and set collapsed to match.\n                        var blocks = element.querySelectorAll(\"g.blocklyDraggable[data-id]:not(.blocklyInsertionMarker)\");\n                        for (let i = 0; i < blocks.length; i++) {\n                            const b = blocks[i];\n                            var bId = b.getAttribute(\"data-id\");\n                            workspace.getBlockById(bId).setCollapsed(collapsed);\n                        }\n                        if (collapsed) { //Change button\n                            collapse.innerText = \"⬇️\";\n                        } else {\n                            collapse.innerText = \"⬆️\";\n                        }\n                    }\n                }, {\n                    capture: true\n                });\n\n                save.addEventListener(\"pointerdown\", (event) => { //Save button handler\n                    event.stopPropagation();\n                    event.preventDefault();\n                    if (element.hasAttribute(\"data-id\") && devWrapper.querySelector(\"div[data-isblocklydeveditor]\")) {\n                        devWrapper.querySelector(\"div[data-isblocklydeveditor]\").save(); //Delegate saving to the editor\n                    }\n                }, {\n                    capture: true\n                });\n\n                bin.addEventListener(\"pointerdown\", (event) => { //Force delete handler\n                    event.stopPropagation();\n                    event.preventDefault();\n                    if (element.hasAttribute(\"data-id\")) {\n                        blockId = element.getAttribute(\"data-id\");\n                        workspace.getBlockById(blockId).dispose(false); //dispose(false) means \"do not heal stack\"\n                        if (workspace.getToolbox() //If the blockly instance has a toolbox, it needs to be refreshed,\n                        ) {\n                            workspace.getToolbox().refreshSelection();\n                        }\n                    }\n                }, {\n                    capture: true\n                });\n\n                var updateObserver = new MutationObserver(function () { //When this block updates\n                    blockId = element.getAttribute(\"data-id\");\n                    bbox = path.getBBox();\n\n                    devWrapper.setAttributeNS(null, \"class\", \"blocklyText\");\n                    devWrapper.setAttributeNS(null, \"y\", \"0\");\n                    devWrapper.setAttributeNS(null, \"text-anchor\", \"middle\");\n                    devWrapper.setAttributeNS(null, \"dominant-baseline\", \"middle\");\n                    devWrapper.setAttributeNS(null, \"dy\", \"0\");\n                    devWrapper.setAttributeNS(null, \"x\", bbox.width);\n                    devWrapper.setAttributeNS(null, \"transform\", `translate(0, 0) `);\n\n                    updateObserver.disconnect();\n                    element.appendChild(devWrapper); //Move element to be last, to allow displaying on top of other blocks connected underneath. (When an element is already appended, appendChild() moves rather than appends)\n                    updateObserver.observe(element, observerConfig);\n                });\n                updateObserver.observe(element, observerConfig); //Initialise observer\n            }\n        }\n        var observer = new MutationObserver(mutationHandler);\n\n        function mutationHandler(mutationRecords) { //Handler that tries to process all blocks every time the block canvas changes.\n            mutationRecords.forEach(function (mutation) {\n                mutation.addedNodes.forEach(function (node) {\n                    processBlock(node);\n                });\n            });\n        }\n\n        //Initial block processing\n        var blocks = getBlocklyBlockCanvas().children;\n        for (let i = 0; i < blocks.length; i++) {\n            const block = blocks[i];\n            processBlock(block);\n        }\n\n        //Observe canvas\n        observer.observe(getBlocklyBlockCanvas(), observerConfig);\n    }\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}